# Core React — Cursor Rules

## Role and Expertise

You are an expert React developer and educator. You write clean, modern React code following hooks and functional component patterns. Your code demonstrates best practices, is well-documented, and serves as a learning reference.

## Project Overview

This is an educational React repository covering topics from fundamentals to advanced patterns. It is organized as a collection of standalone examples and mini-applications — not a production app. Each directory represents a topic area with progressive complexity.

## Code Style

### General Principles
- Follow **ESLint** and **Prettier** configurations strictly.
- Write **functional components** with hooks (no class components in new examples).
- Use **TypeScript** where beneficial for type safety (optional, depends on repo).
- Prefer **clarity over cleverness** — this is an educational repo.
- Maximum line length of **100 characters**.
- Use **const** for component definitions and immutable values.
- Keep components **small and focused** (under 150 lines).

### Naming Conventions
- **Components**: `PascalCase` (e.g., `UserProfile`, `TodoList`)
- **Hooks**: `camelCase` with `use` prefix (e.g., `useAuth`, `useFetch`)
- **Utilities**: `camelCase` (e.g., `formatDate`, `validateEmail`)
- **Constants**: `UPPER_SNAKE_CASE` (e.g., `API_BASE_URL`)
- **Props interfaces**: `ComponentNameProps` (e.g., `UserProfileProps`)
- **Files**: `PascalCase.jsx/tsx` for components, `camelCase.js/ts` for utilities

## Project Structure

```
core-reactjs/
├── fundamentals/         # JSX, props, state, events
├── components/           # Component patterns, composition
├── hooks/                # useState, useEffect, useRef, custom hooks
├── state-management/     # Context, Zustand, simple patterns
├── forms/                # Controlled, uncontrolled, validation
├── routing/              # React Router examples
├── performance/          # Memoization, lazy loading, optimization
├── patterns/             # HOCs, render props, compound components
├── testing/              # Testing Library, Jest examples
├── styling/              # CSS modules, styled-components, Tailwind
└── advanced/             # Suspense, error boundaries, portals
```

## Component Patterns

### Functional Components
- Use **arrow functions** or **function declarations** (be consistent).
- **Destructure props** for clarity.
- Keep **JSX return** at the end of component.
- Use **early returns** for conditional rendering.
- Extract **complex JSX** into smaller components.

### Component Example
```jsx
// Good: Clear, focused component
function UserCard({ user, onEdit }) {
  // Early return for loading/error states
  if (!user) {
    return <div>No user data</div>;
  }

  return (
    <div className="user-card">
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Edit</button>
    </div>
  );
}

// TypeScript version
interface UserCardProps {
  user?: User;
  onEdit: (id: string) => void;
}

function UserCard({ user, onEdit }: UserCardProps) {
  // Same implementation
}
```

## Hooks Best Practices

### useState
- Use **separate state variables** for unrelated values.
- Use **state updater functions** when new state depends on old (`setState(prev => ...)`).
- Use **lazy initialization** for expensive initial state.

### useEffect
- Keep effects **focused** (one effect per concern).
- Always include **dependencies** (don't disable exhaustive-deps).
- Return **cleanup functions** for subscriptions, timers, listeners.
- Avoid **objects in dependencies** (extract primitives or use useCallback).

### Custom Hooks
- Extract **reusable logic** into custom hooks.
- Name custom hooks with **use** prefix.
- Return **arrays** for unnamed values, **objects** for named values.
- Keep hooks **pure** (no side effects in initial execution).

### Hook Examples
```jsx
// Custom hook for data fetching
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let cancelled = false;

    async function fetchData() {
      try {
        const response = await fetch(url);
        const json = await response.json();
        if (!cancelled) {
          setData(json);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    }

    fetchData();

    return () => {
      cancelled = true; // Cleanup
    };
  }, [url]);

  return { data, loading, error };
}

// Usage
function UserList() {
  const { data: users, loading, error } = useFetch('/api/users');

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## State Management

- Use **useState** for local component state.
- Use **useReducer** for complex state logic (multiple sub-values, state machine).
- Use **Context API** for global state (theme, auth, language).
- Avoid **prop drilling** with composition or context.
- Use **compound components** for related component groups.

### Context Example
```jsx
const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook for consuming context
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}
```

## Performance Optimization

- Use **React.memo()** for expensive components (profile first).
- Use **useMemo()** for expensive calculations.
- Use **useCallback()** for stable function references in dependencies.
- Use **lazy loading** with React.lazy() and Suspense.
- Avoid **premature optimization** — profile first.
- Use **key prop** correctly (stable, unique identifiers).

### Performance Example
```jsx
// Memoize expensive calculation
function ProductList({ products, filters }) {
  const filteredProducts = useMemo(() => {
    return products.filter(p =>
      p.price >= filters.minPrice &&
      p.price <= filters.maxPrice
    );
  }, [products, filters]);

  return (
    <ul>
      {filteredProducts.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </ul>
  );
}

// Memoize component
const ProductCard = memo(function ProductCard({ product }) {
  return (
    <div className="product-card">
      <h3>{product.name}</h3>
      <p>${product.price}</p>
    </div>
  );
});
```

## Error Handling

- Use **Error Boundaries** for component error handling.
- Show **user-friendly error messages** (not stack traces).
- Provide **fallback UI** for errors.
- Log errors to **error tracking service** in production.
- Handle **async errors** in useEffect with try-catch.

## Clean Code Principles

- **Single Responsibility**: Each component should do one thing.
- **DRY**: Extract repeated JSX into components or utilities.
- **Meaningful Names**: Component and prop names should be self-documenting.
- **Small Components**: Keep components focused (max 150 lines).
- **Composition**: Build complex UIs from simple components.
- **Props Validation**: Use PropTypes or TypeScript for prop validation.

## Documentation Standards

- Every example file should have a **header comment** explaining the concept.
- Document **complex components** with JSDoc or inline comments.
- Use **Storybook** for component documentation (optional, for larger examples).
- Each directory has a **README.md** explaining the topic and examples.
- Include **visual examples** (screenshots, GIFs) where helpful.
- Keep the root **README.md** in sync with the directory structure.

## Educational Patterns

- **Show evolution**: Start with simple examples, add complexity gradually.
- **Compare approaches**: Show class components vs hooks (historical context).
- **Demonstrate anti-patterns**: Show what NOT to do and why.
- **Include comments**: Explain non-obvious React behavior (closure caveats, reconciliation).
- **Use console.log()**: Demonstrate component lifecycle and re-renders.
- **Provide CodeSandbox links**: For interactive examples (optional).

### Educational Example
```jsx
// Show evolution from prop drilling to context

// ❌ Anti-pattern: Prop drilling
function App() {
  const [user, setUser] = useState(null);
  return <Dashboard user={user} setUser={setUser} />;
}

function Dashboard({ user, setUser }) {
  return <Sidebar user={user} setUser={setUser} />;
}

function Sidebar({ user, setUser }) {
  return <UserMenu user={user} setUser={setUser} />;
}

// ✅ Better: Context API
const UserContext = createContext();

function App() {
  const [user, setUser] = useState(null);
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <Dashboard />
    </UserContext.Provider>
  );
}

function UserMenu() {
  const { user, setUser } = useContext(UserContext);
  // Use user and setUser directly
}
```

## Testing Best Practices

- Test **user behavior**, not implementation details.
- Use **React Testing Library** (not Enzyme).
- Use **semantic queries** (getByRole, getByLabelText).
- Test **accessibility** (screen reader compatibility).
- Mock **API calls** with MSW or simple mocks.
- Test **error states** and **edge cases**.

### Testing Example
```jsx
import { render, screen, fireEvent } from '@testing-library/react';

test('increments counter when button clicked', () => {
  render(<Counter />);

  const button = screen.getByRole('button', { name: /increment/i });
  const count = screen.getByText(/count: 0/i);

  fireEvent.click(button);

  expect(screen.getByText(/count: 1/i)).toBeInTheDocument();
});
```

## React Best Practices

- Use **strict mode** in development (`<React.StrictMode>`).
- Keep **components pure** (same props → same output).
- Use **fragments** to avoid unnecessary div wrappers.
- Use **semantic HTML** for accessibility.
- Provide **alt text** for images.
- Handle **loading and error states** explicitly.
- Use **controlled components** for forms (single source of truth).
